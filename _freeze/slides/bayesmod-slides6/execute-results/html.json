{
  "hash": "0fa8de3d864324a06a0590a76d66b481",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian modelling\"\nauthor: \"LÃ©o Belzile\"\nsubtitle: \"Bayesian workflow and computational strategies\"\ndate: today\ndate-format: \"[Last compiled] dddd MMM D, YYYY\"\neval: true\necho: true\ncache: true\nbibliography: MATH80601A.bib\nformat:\n  revealjs:\n    slide-number: true\n    preview-links: auto\n    theme: [simple, hecmontreal.scss]\n    title-slide-attributes:\n      data-background-color: \"#ff585d\"\n    logo: \"fig/logo_hec_montreal_bleu_web.png\"\n---\n\n\n\n\n\n\n\n## Visual diagnostic: trace plots\n\nDisplay the Markov chain sample path as a function of the number of iterations.\n\n- Run multiple chains to see if they converge to the same target.\n   - if not, check starting values (compare log posterior) or parameter identifiability!\n- Markov chains should look like a fat hairy caterpillar!\n- `bayesplot` and `coda` have functionalities for plots (trace plot, trace rank, correlograms, marginal densities, etc.)\n\n\n## Checking convergence with multiple chains\n\n\n![Four healthy parallel chains for parameters.](fig/catterpillar_traceplots.png)\n\n## Effective sample size\n\nAre my chains long enough to compute reliable summaries?\n\nCompute the sample size we would have with independent draws by taking\n$$\n\\mathsf{ESS} = \\frac{B}{\\left\\{1+2\\sum_{t=1}^\\infty \\gamma_t\\right\\}}\n$$ \nwhere $\\gamma_t$ is the lag $t$ autocorrelation. \n\nThe relative effective sample size is simply $\\mathsf{ESS}/B$: small values indicate pathological or inefficient samplers. \n\n## How many samples?\n\nWe want our average estimate to be reliable!\n\n- We probably need $\\mathsf{ESS}$ to be several hundred \n- We can estimate the variance of the target to know the precision\n\n- (related question: how many significant digits to report?)\n\nIn **R**, via `coda::effectiveSize()`\n\n## Estimating the variance (block method)\n\n1. Break the chain of length $B$ (after burn in) in $K$ blocks of size $\\approx K/B$.\n2. Compute the sample mean of each segment. These values form a Markov chain and should be approximately uncorrelated.\n3. Compute the standard deviation of the segments mean. Rescale by $K^{-1/2}$ to get standard error of the global mean.\n\nMore efficient methods using overlapping blocks exists.\n\n## Block means in pictures\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Calculation of the standard error of the posterior mean using the batch method.](bayesmod-slides6_files/figure-revealjs/fig-mcmc-batchmean-1.png){#fig-mcmc-batchmean width=960}\n:::\n:::\n\n\n\n\n## Cautionary warning about stationarity\n\nBatch means only works if the chain is sampling from the stationary distribution! \n\nThe previous result (and any estimate) will be unreliable and biased if the chain is not (yet) sampling from the posterior.\n\n## Lack of stationarity\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Traceplots of three Markov chains for the same target with different initial values for the first 500 iterations (left) and trace rank plot after discarding these (right). The latter is indicative of the speed of mixing.](bayesmod-slides6_files/figure-revealjs/fig-badstart-1.png){#fig-badstart width=960}\n:::\n:::\n\n\n\n## Potential scale reduction statistic \n\nThe Gelman--Rubin diagnostic, denoted $\\widehat{R}$, is obtained by running multiple chains and considering the difference between within-chain and between-chains variances,\n\n\\begin{align*}\n\\widehat{R} = \\left(\\frac{\\mathsf{Va}_{\\text{within}}(B-1) + \\mathsf{Va}_{\\text{between}}}{B\\mathsf{Va}_{\\text{within}}}\\right)^{1/2}\n\\end{align*}\n\n\nAny value of $\\widehat{R}$ larger 1 is indicative of problems of convergence.\n\n## Bad chains\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Two pairs of Markov chains: the top ones seem stationary, but with different modes and  $\\widehat{R} \\approx 3.4$. The chains on the right hover around zero, but do not appear stable, with $\\widehat{R} \\approx 1.6$.](bayesmod-slides6_files/figure-revealjs/fig-rhat-1.png){#fig-rhat width=960}\n:::\n:::\n\n\n\n\n## Posterior predictive checks\n\n1. For each of the $B$ draws from the posterior, simulate $n$ observations from the posterior predictive $p(\\widetilde{\\boldsymbol{y}} \\mid \\boldsymbol{y})$\n2. For each replicate, compute a summary statistics (median, quantiles, std. dev., etc.) \n3. Compare it with the same summary computed for the sample $\\boldsymbol{y}$.\n\n## Posterior predictive checks\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Posterior predictive checks for the standard deviation (top) and density of posterior draws (bottom) for hierarchical Poisson model with individual effects (left) and simpler model with only conditions (right).](fig/fig-posterior-pred-check.png){#fig-posterior-pred-check width=448}\n:::\n:::\n\n\n\n## Log pointwise predictive density\n\nConsider the expected value of the log observation-wise log density with respect to the posterior distribution $p(\\boldsymbol{\\theta} \\mid \\boldsymbol{y})$, \n\\begin{align*}\n\\mathsf{LPPD}_i = \\mathsf{E}_{\\boldsymbol{\\theta} \\mid \\boldsymbol{y}} \\left\\{ \\log p(y_i \\mid \\boldsymbol{\\theta})\\right\\},\n\\end{align*}\n \nThe higher the value of $\\mathsf{LPPD}_i$, the better the fit for that observation.\n\n## Widely available information criterion \n\nTo build an information criterion, we add a penalization factor that approximates the effective number of parameters in the model, with\n\\begin{align*}\nn\\mathsf{WAIC} = -\\sum_{i=1}^n \\mathsf{LPPD}_i + \\sum_{i=1}^n \\mathsf{Va}_{\\boldsymbol{\\theta} \\mid \\boldsymbol{y}}\\{\\log p(y_i \\mid \\boldsymbol{\\theta})\\}\n\\end{align*} \nwhere we use again the empirical variance to compute the rightmost term.\n\nSmaller values of $\\mathsf{WAIC}$ are better.\n\n## Bayesian leave-one-out cross validation\n\nIn Bayesian setting, we can use the leave-one-out predictive density\n$$p(y_i \\mid \\boldsymbol{y}_{-i})$$ as a measure of predictive accuracy. the \n\nWe can use importance sampling to approximate the latter.\n\nRequirement: need to keep track of the log likelihood of each observation for each posterior draw ($B \\times n$ values).\n\n## LOO-CV diagnostics\n\nWe can draw $B$ samples from  $p(\\widetilde{y} \\mid \\boldsymbol{y}_{-i})$ and compute the rank of $y_i$.\n\nUnder perfect calibration, ranks should be uniform.\n\n## Leave-one-out with quantile-quantile plots\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Quantile-quantile plots based on leave-one-out cross validation for model for the hierarchical Poisson model fitted to the Upworthy data with the individual random effects (left) and without (right).](fig/fig-loocv-qqplots.png){#fig-posterior-loocv width=448}\n:::\n:::\n\n\n\n\n\n\n## References\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}