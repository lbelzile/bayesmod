{
  "hash": "ebcab402e111cba93f0a76519983dfaa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Bayesian modelling\"\nauthor: \"LÃ©o Belzile\"\nsubtitle: \"Computational strategies and diagnostics\"\ndate: today\ndate-format: \"[Last compiled] dddd MMM D, YYYY\"\neval: true\necho: true\ncache: true\nbibliography: MATH80601A.bib\nformat:\n  revealjs:\n    slide-number: true\n    preview-links: auto\n    theme: [simple, hecmontreal.scss]\n    title-slide-attributes:\n      data-background-color: \"#ff585d\"\n    logo: \"fig/logo_hec_montreal_bleu_web.png\"\n---\n\n\n\n\n\n## Outline\n\nHow do we assess convergence of a MCMC algorithm?\n\n- the algorithm implementation must be correct,\n- the chain must have converged to the target posterior.\n- the effective sample size must be sufficiently large for inference.\n\n## Strategies\n\nMany diagnostics require running multiple chains\n\n- check within vs between variance,\n- determine whether they converge to the same target.\n\n## Correct implementation\n\nWe can generate artificial data to check the procedure.\n\n\nSimulation-based calibration  [@Talts:2020] proceeds with, in order\n\n1. $\\boldsymbol{\\theta}_0 \\sim p(\\boldsymbol{\\theta}),$\n2. $\\boldsymbol{y}_0 \\sim p(\\boldsymbol{y} \\mid \\boldsymbol{\\theta}_0),$\n3. $\\boldsymbol{\\theta}_1, \\ldots, \\boldsymbol{\\theta}_B \\sim p(\\boldsymbol{\\theta} \\mid \\boldsymbol{y}_0 ).$\n\n\n## Simulation-based calibration\n\n- Conditional on the simulated $\\boldsymbol{y}$, the distribution of $\\boldsymbol{\\theta}_0$ is the same as that of $\\boldsymbol{\\theta}_1, \\ldots, \\boldsymbol{\\theta}_B.$\n- We do a dimension reduction step taking the test function $t(\\cdot)$ to get the rank of the prior draw among the posterior ones, breaking ties at random if any.\n- These steps are repeated $K$ times, yielding $K$ test functions $T_1, \\ldots, T_K.$ We then test for uniformity using results from @Sailynoja:2022.\n\n## Breaking down the Markov chain\n\nWe distinguish between three phases\n\n- **burn in** period: initial draws allowing the algorithm to converge to it's stationary distribution (discarded)\n- **warmup** adaptation period: tuning period for the proposal std. deviation, etc. (discarded)\n- sampling period: draws post burn in and warmup that are kept for inference\n\nWe can optionally **thin** by keeping one every $k$ iterations from the sampling period to reduce the storage.\n\n## Visual diagnostic: trace plots\n\nDisplay the Markov chain sample path as a function of the number of iterations.\n\n- Ideally, run multiple chains to see if they converge to the same mode (for multimodal behaviour).\n- Markov chains should look like a fat hairy caterpillar!\n- Check the `bayesplot` and `coda` **R** packages (trace plot, trace rank, correlograms, marginal densities, etc.)\n\n\n## Checking convergence with multiple chains\n\n\n![Four healthy parallel chains for parameters.](fig/catterpillar_traceplots.png)\n\n## Trace rank plot\n\n\nA **trace rank** plot compares the rank of the values of the different chain at a given iteration.\n\n\n- With good mixing, the ranks should switch frequently and be distributed uniformly across integers.\n\n\n\n## Effective sample size\n\nAre my chains long enough to compute reliable summaries?\n\nCompute the sample size we would have with independent draws by taking\n$$\n\\mathsf{ESS} = \\frac{B}{\\left\\{1+2\\sum_{t=1}^\\infty \\gamma_t\\right\\}}\n$$ \nwhere $\\gamma_t$ is the lag $t$ autocorrelation. \n\nThe relative effective sample size is simply $\\mathsf{ESS}/B$: small values indicate pathological or inefficient samplers. \n\n## How many samples?\n\nWe want our average estimate to be reliable!\n\n- We probably need $\\mathsf{ESS}$ to be several hundred \n- We can estimate the variance of the target to know the precision\n\n- (related question: how many significant digits to report?)\n\n\n## Estimating the variance (block method)\n\n1. Break the chain of length $B$ (after burn in) in $K$ blocks of size $\\approx K/B$.\n2. Compute the sample mean of each segment. These values form a Markov chain and should be approximately uncorrelated.\n3. Compute the standard deviation of the segments mean. Rescale by $K^{-1/2}$ to get standard error of the global mean.\n\nMore efficient methods using overlapping blocks exists.\n\n## Block means in pictures\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Calculation of the standard error of the posterior mean using the batch method.](bayesmod-slides6_files/figure-revealjs/fig-mcmc-batchmean-1.png){#fig-mcmc-batchmean width=960}\n:::\n:::\n\n\n\n\n## Cautionary warning about stationarity\n\nBatch means only works if the chain is sampling from the stationary distribution! \n\nThe previous result (and any estimate) will be unreliable and biased if the chain is not (yet) sampling from the posterior.\n\n## Lack of stationarity\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Traceplots of three Markov chains for the same target with different initial values for the first 500 iterations (left) and trace rank plot after discarding these (right). The latter is indicative of the speed of mixing.](bayesmod-slides6_files/figure-revealjs/fig-badstart-1.png){#fig-badstart width=960}\n:::\n:::\n\n\n\n\n## Gelman--Rubin diagnostic\n\nSuppose we run $M$ chains for $B$ iterations, post burn in. \n\nDenote by $\\theta_{bm}$ the $b$th draw of the $m$th chain, we compute the global average \n$$\\overline{\\theta} = \\frac{1}{BM}\\sum_{b=1}^B \\sum_{m=1}^m \\theta_{bm}$$ and similarly the chain-specific sample average and variances, respectively $\\overline{\\theta}_m$ and $\\widehat{\\sigma}^2_m$ ($m=1, \\ldots, M$). \n\n## Sum of square decomposition\n\nThe between-chain variance and within-chain variance estimator are\n\\begin{align*}\n\\mathsf{Va}_{\\text{between}} &= \\frac{B}{M-1}\\sum_{m=1}^M (\\overline{\\theta}_m - \\overline{\\theta})^2\\\\\n\\mathsf{Va}_{\\text{within}} &= \\frac{1}{M}\\sum_{m=1}^m \\widehat{\\sigma}^2_m\n\\end{align*}\n\n## Potential scale reduction statistic \n\nThe Gelman--Rubin diagnostic, denoted $\\widehat{R}$, is obtained by running multiple chains and considering the difference between within-chain and between-chains variances,\n\n\\begin{align*}\n\\widehat{R} = \\left(\\frac{\\mathsf{Va}_{\\text{within}}(B-1) + \\mathsf{Va}_{\\text{between}}}{B\\mathsf{Va}_{\\text{within}}}\\right)^{1/2}\n\\end{align*}\n\n\nAny value of $\\widehat{R}$ larger 1 is indicative of problems of convergence.\n\n## Bad chains\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Two pairs of Markov chains: the top ones seem stationary, but with different modes and  $\\widehat{R} \\approx 3.4$. The chains on the right hover around zero, but do not appear stable, with $\\widehat{R} \\approx 1.6$.](bayesmod-slides6_files/figure-revealjs/fig-rhat-1.png){#fig-rhat width=960}\n:::\n:::\n\n\n\n## One chain or multiple chains?\n\nGenerally, it is preferable to run a single chain for a longer period than run multiple chains sequentially\n\n- there is a cost to initializing multiple times with different starting values since we must discard initial draws.\n- but with parallel computations, multiple chains are more frequent nowadays.\n- multiple diagnostics require running several chains.\n\n\n## Posterior predictive checks\n\n1. For each of the $B$ draws from the posterior, simulate $n$ observations from the posterior predictive $p(\\widetilde{\\boldsymbol{y}} \\mid \\boldsymbol{y})$\n2. For each replicate, compute a summary statistics (median, quantiles, std. dev., etc.) \n3. Compare it with the same summary computed for the sample $\\boldsymbol{y}$.\n\n## Posterior predictive checks\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Posterior predictive checks for the standard deviation (top) and density of posterior draws (bottom) for hierarchical Poisson model with individual effects (left) and simpler model with only conditions (right).](fig/fig-posterior-pred-check.png){#fig-posterior-pred-check width=672}\n:::\n:::\n\n\n\n## Log pointwise predictive density\n\nConsider the expected value of the log observation-wise log density with respect to the posterior distribution $p(\\boldsymbol{\\theta} \\mid \\boldsymbol{y})$, \n\\begin{align*}\n\\mathsf{LPPD}_i = \\mathsf{E}_{\\boldsymbol{\\theta} \\mid \\boldsymbol{y}} \\left\\{ \\log p(y_i \\mid \\boldsymbol{\\theta})\\right\\},\n\\end{align*}\n \nThe higher the value of $\\mathsf{LPPD}_i$, the better the fit for that observation.\n\n## Widely available information criterion \n\nTo build an information criterion, we add a penalization factor that approximates the effective number of parameters in the model, with\n\\begin{align*}\nn\\mathsf{WAIC} = -\\sum_{i=1}^n \\mathsf{LPPD}_i + \\sum_{i=1}^n \\mathsf{Va}_{\\boldsymbol{\\theta} \\mid \\boldsymbol{y}}\\{\\log p(y_i \\mid \\boldsymbol{\\theta})\\}\n\\end{align*} \nwhere we use again the empirical variance to compute the rightmost term.\n\nSmaller values of $\\mathsf{WAIC}$ are better.\n\n## Pseudo-code for WAIC\n\nEvaluate the log likelihood for each posterior draw and each observation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' WAIC\n#' @param loglik_pt B by n matrix of pointwise log likelihood\nWAIC <- function(loglik_pt){\n  -mean(apply(loglik_pt, 2, mean)) +  mean(apply(loglik_pt, 2, var))\n}\n```\n:::\n\n\n\n## Bayesian leave-one-out cross validation\n\nIn Bayesian setting, we can use the leave-one-out predictive density\n$$p(y_i \\mid \\boldsymbol{y}_{-i})$$ as a measure of predictive accuracy. the \n\nWe can use importance sampling to approximate the latter.\n\nRequirement: need to keep track of the log likelihood of each observation for each posterior draw ($B \\times n$ values).\n\n## LOO-CV diagnostics\n\nWe can draw $B$ samples from  $p(\\widetilde{y} \\mid \\boldsymbol{y}_{-i})$ and compute the rank of $y_i$.\n\nUnder perfect calibration, ranks should be uniform.\n\n## Leave-one-out with quantile-quantile plots\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Quantile-quantile plots based on leave-one-out cross validation for model for the hierarchical Poisson model fitted to the Upworthy data with the individual random effects (left) and without (right).](fig/fig-loocv-qqplots.png){#fig-posterior-loocv width=672}\n:::\n:::\n\n\n\n\n## Deviance information criterion\n\n\nThe **deviance** information criterion of @Spiegelhalter:2002 is\n\\begin{align*}\n\\mathsf{DIC} = -2 \\ell(\\widetilde{\\boldsymbol{\\theta}}) + 2 p_D\n\\end{align*}\nwhere $p_D$ is the posterior expectation of the deviance relative to the point estimator of the parameter $\\widetilde{\\boldsymbol{\\theta}}$ (e.g., the maximum a posteriori or the posterior mean)\n\\begin{align*}\np_D = \\mathsf{E}\\{D(\\boldsymbol{\\theta}, \\widetilde{\\boldsymbol{\\theta}}) \\mid \\boldsymbol{y}\\}= \\int 2 \\{ \\ell(\\widetilde{\\boldsymbol{\\theta}}) - \\ell(\\boldsymbol{\\theta})\\} f(\\boldsymbol{\\theta} \\mid \\boldsymbol{y} \\mathrm{d} \\boldsymbol{\\theta}\n\\end{align*}\n\n\n## Criticism of DIC\n\n- The DIC can be easily evaluated by keeping track of the log likelihood evaluated at each posterior draw from a Markov chain Monte Carlo algorithm.\n- The penalty term $p_D$ is however not invariant to reparametrizations.\n- A Gaussian approximation to the MLE under suitable regularity conditions shows that the $\\mathsf{DIC}$ is equivalent in large samples to $\\mathsf{AIC}.$\n\n# Computational strategies\n\n## Sources of poor mixing\n\nSlow mixing can be due to the following:\n\n- poor proposals\n- strong correlation between posterior parameters\n- overparametrization and lack of identifiability\n\n\n## Computational strategies\n\nThese problems can be addressed using one of the following:\n\n- removing redundant parameters or pinning some using sharp priors\n- reparametrization\n- clever proposals (adaptive MCMC), see @Andrieu.Thoms:2008 and @Rosenthal:2011.\n- marginalization\n- blocking\n\n## Removing redundant parameters\n\nConsider a one-way ANOVA with $K$ categories, with observation $i$ from group $k$ having\n\\begin{align*}\nY_{i,k} &\\sim \\mathsf{Gauss}(\\mu + \\alpha_k, \\sigma^2_y) \\\\\n\\alpha_k &\\sim \\mathsf{Gauss}(0, \\sigma^2_\\alpha)\n\\end{align*}\nand an improper prior for the mean $p(\\mu) \\propto 1.$\n\nThere are $K+1$ mean parameters for the groups, so we can enforce a sum-to-zero constraint for $\\sum_{k=1}^K \\alpha_k=0$ and sample $K-1$ parameters for the difference to the global mean.\n\n## Parameter expansion\n\nAdd redundant parameter to improve mixing by decorrelating [@Liu.Rubin.Wu:1998]\n\n\\begin{align*}\nY_{i,k} &\\sim \\mathsf{Gauss}(\\mu + \\xi\\eta_k, \\sigma^2_y) \\\\\n\\eta_k &\\sim \\mathsf{Gauss}(0, \\sigma^2_\\eta)\n\\end{align*}\nso that $\\sigma_\\alpha = |\\xi|\\sigma_\\eta.$\n\n## Marginalization\n\nGiven a model $p(\\boldsymbol{\\theta}, \\boldsymbol{Z})$, reduce the dependance by sampling from the marginal\n\n$$\np(\\boldsymbol{\\theta})= \\int p(\\boldsymbol{\\theta}, \\boldsymbol{z}) \\mathrm{d} \\boldsymbol{z}.\n$$\n\nThis happens for data augmentation, etc., and reduces dependency between parameters, but typically the likelihood becomes more expensive to compute\n\n## Gaussian model with random effects\n\n\nConsider a hierarchical Gaussian model of the form\n\\begin{align*}\n\\boldsymbol{Y} = \\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{Z}\\boldsymbol{B} + \\boldsymbol{\\varepsilon}\n\\end{align*}\nwhere\n\n- $\\mathbf{X}$ is an $n \\times p$ design matrix with centered inputs,\n- $\\boldsymbol{\\beta} \\sim \\mathsf{Gauss}(\\boldsymbol{0}_p, \\sigma^2\\mathbf{I}_p),$\n- $\\boldsymbol{B}\\sim \\mathsf{Gauss}_q(\\boldsymbol{0}_q, \\boldsymbol{\\Omega})$ are random effects and\n- $\\boldsymbol{\\varepsilon} \\sim \\mathsf{Gauss}_n(\\boldsymbol{0}_n, \\kappa^2\\mathbf{I}_n)$ are independent white noise.\n\n## Marginalization of Gaussian models\n\nWe can write\n\\begin{align*}\n\\boldsymbol{Y} \\mid \\mathbf{\\beta}, \\boldsymbol{B} &\\sim \\mathsf{Gauss}_n(\\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{Z}\\boldsymbol{B},  \\sigma^2\\mathbf{I}_p)\\\\\n\\boldsymbol{Y} \\mid \\mathbf{\\beta} &\\sim \\mathsf{Gauss}_n(\\mathbf{X}\\boldsymbol{\\beta}, \\mathbf{Q}^{-1}),\n\\end{align*}\nwhere the second line corresponds to marginalizing out the random effects $\\boldsymbol{B}.$\n\n## Efficient calculations for Gaussian models\n\nIf, as is often the case, $\\boldsymbol{\\Omega}^{-1}$ and $\\mathbf{Z}$ are sparse matrices, the full precision matrix can be efficiently computed using Shermann--Morisson--Woodbury identity as\n\\begin{align*}\n\\mathbf{Q}^{-1} &=   \\mathbf{Z}\\boldsymbol{\\Omega}^{-1}\\mathbf{Z}^\\top + \\kappa^2 \\mathbf{I}_n,\\\\\n\\kappa^2\\mathbf{Q} & = \\mathbf{I}_n - \\mathbf{Z} \\boldsymbol{G}^{-1} \\mathbf{Z}^\\top,\\\\\n\\boldsymbol{G} &= \\mathbf{Z}^\\top\\mathbf{Z} + \\kappa^2 \\boldsymbol{\\Omega}^{-1}\n\\end{align*}\nSection 3.1 of @Nychka:2015 details efficient ways of calculating the quadratic form involving $\\mathbf{Q}$ and it's determinant.\n\n## Blocking\n\nIdentify groups of strongly correlated parameters and propose a joint update for these.\n\n- The more parameters we propose at the same time, the lower the chance of acceptance\n- Often ways to sample these efficiently\n\n\n## Tokyo rainfall\n\nWe consider data from @Kitagawa:1987 that provide a binomial time series giving the number of days in years 1983 and 1984 (a leap year) in which there was more than 1mm of rain in Tokyo; see section 4.3.4 of @Rue.Held:2005.\n\n\nWe have $T=366$ days and $n_t \\in \\{1,2\\}$ $(t=1, \\ldots, T)$ the number of observations in day $t$ and $y_t=\\{0,\\ldots, n_t\\}$ the number of days with rain.\n\n\n## Smoothing probabilities\n\nThe objective is to obtain a smoothed probability of rain. The underlying probit model considered takes $Y_t \\mid n_t, p_t \\sim \\mathsf{binom}(n_t, p_t)$ and $p_t = \\Phi(\\beta_t).$\n\n\n\nWe specify the random effects $\\boldsymbol{\\beta} \\sim \\mathsf{Gauss}_{T}(\\boldsymbol{0}, \\tau^{-1}\\mathbf{Q}),$ where $\\mathbf{Q}$ is a $T \\times T$ precision matrix that encodes the local dependence. \n\nA circular random walk structure of order 2 is used to model the smooth curves by smoothing over neighbors, and enforces small second derivative. This is a suitable prior because it enforces no constraint on the mean structure. \n\n## Random walk prior\n\nThis amounts to specifying the process with for $t \\in \\mathbb{N} \\mod 366 + 1$\n\\begin{align*}\n\\Delta^2\\beta_t &= (\\beta_{t+1} - \\beta_t) - (\\beta_t - \\beta_{t-1})\n\\\\&=-\\beta_{t-1} +2 \\beta_t - \\beta_{t+1} \\sim \\mathsf{Gauss}(0, \\tau^{-1}).\n\\end{align*}\n\n## Circulant precision matrix\n\nThis yields an intrinsic Gaussian Markov random field with a circulant precision matrix $\\tau\\mathbf{Q}$ of rank $T-1,$ where\n\\begin{align*}\n\\mathbf{Q} &=\n\\begin{pmatrix}\n6 & -4 & 1 & 0 & \\cdots & 1 & -4\\\\\n-4 & 6 & -4 & 1 & \\ddots & 0 & 1 \\\\\n1 & -4 & 6 & -4 & \\ddots & 0 & 0 \\\\\n\\vdots & \\ddots & \\ddots  & \\ddots  & \\ddots  & \\ddots & \\vdots \\\\\n-4 & 1 & 0 & 0 & \\cdots & -4 & 6\n\\end{pmatrix}.\n\\end{align*}\nBecause of the linear dependency, the determinant of $\\mathbf{Q}$ is zero.\n\n\n## Prior draws\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Five realizations from the cyclical random walk Gaussian prior of order 2.](bayesmod-slides6_files/figure-revealjs/fig-CRW2-prior-1.png){#fig-CRW2-prior width=960}\n:::\n:::\n\n\n\n## Gibbs sampling for Tokyo data\n\n\nWe can perform data augmentation by imputing Gaussian variables, say $\\{z_{t,i}\\}$ from truncated Gaussian, where $z_{t,i} = \\beta_t + \\varepsilon_{t,i}$ and $\\varepsilon_{t,i} \\sim \\mathsf{Gauss}(0,1)$ are independent standard Gaussian and\n\\begin{align*}\nz_{t,i} \\mid  y_{t,i}, \\beta_t \\sim\n\\begin{cases}\n\\mathsf{trunc. Gauss}(\\beta_t, 1, -\\infty, 0) & y_{t,i} = 0 \\\\\n\\mathsf{trunc. Gauss}(\\beta_t, 1,  0, \\infty) & y_{t,i} =1\n\\end{cases}\n\\end{align*}\n\n## Posterior for Tokyo data\n\nThe posterior is proportional to\n\\begin{align*}\np(\\boldsymbol{\\beta} \\mid \\tau)p(\\tau)\\prod_{t=1}^{T}\\prod_{i=1}^{n_t}p(y_{t,i} \\mid z_{t,i}) p(z_{t,i} \\mid \\beta_t)\n\\end{align*}\n\n## Data augmentation for Tokyo data\n\nOnce we have imputed the Gaussian latent vectors, we can work directly with the values of $z_t = \\sum_{i=1}^{n_t} z_{i,t}.$ The posterior is\n\\begin{align*}\np(\\boldsymbol{\\beta}, \\tau) &\\propto \\tau^{(n-1)/2}\\exp \\left( - \\frac{\\tau}{2} \\boldsymbol{\\beta}^\\top \\mathbf{Q} \\boldsymbol{\\beta}\\right)\n\\\\& \\times \\exp\\left\\{ - \\frac{1}{2} (\\boldsymbol{z} - \\boldsymbol{\\beta})^\\top \\mathrm{diag}(\\boldsymbol{n})(\\boldsymbol{z} - \\boldsymbol{\\beta})\\right\\} \\tau^{a-1}\\exp(-\\tau b)\n\\end{align*}\nwhere $\\boldsymbol{z} = (z_1, \\ldots, z_T).$\n\n## Gibbs for Tokyo data - conditionals\n\nCompleting the quadratic form shows that\n\\begin{align*}\n\\boldsymbol{\\beta} \\mid \\boldsymbol{z}, \\tau &\\sim \\mathsf{Gauss}_T\\left[\\left\\{\\tau \\mathbf{Q} + \\mathrm{diag}(\\boldsymbol{n})\\right\\}^{-1} \\boldsymbol{z}, \\left\\{\\tau \\mathbf{Q} + \\mathrm{diag}(\\boldsymbol{n})\\right\\}^{-1}\\right]\\\\\n\\tau \\mid \\boldsymbol{\\beta} & \\sim \\mathsf{gamma}\\left( \\frac{n-1}{2} + a, \\frac{\\boldsymbol{\\beta}^\\top \\mathbf{Q}\\boldsymbol{\\beta}}{2} + b \\right)\n\\end{align*}\n\n## Posterior prediction for probability of rainfall\n\n\n![Posterior prediction for probability of rainfall](fig/fig-rainfall-1.png)\n\n\n## Blocking vs joint update\n\nCompare the following two stategies\n\n- joint update: given $\\boldsymbol{z}$ and $\\tau$, simulate $\\boldsymbol{\\beta}$ jointly\n- one-parameter at a time: starting from $i \\sim \\mathsf{unif}(\\{1, \\ldots, 366\\}),$ get index $t= i \\mod 366 + 1$ and simulate $\\beta_i \\mid \\boldsymbol{\\beta}_{-i}, \\boldsymbol{z}, \\tau$ one at a time.\n\n## Blocking strategy\n\n![Trace plots for Tokyo with blocking of random effects](fig/fig-tokyo-post1-1.png)\n\n## Individual update strategy\n\n![Trace plots for Tokyo with random scan Gibbs for random effects](fig/fig-tokyo-post2-1.png)\n\n\n## Lessons from the Tokyo example\n\n\nWhat happened?\n\n- there is lower autocorrelation with the joint update (also faster here!) for the $\\boldsymbol{\\beta}$\n- in both cases, $\\tau \\mid \\cdot$ mixes poorly because the values of $\\boldsymbol{\\beta}$ were sampled conditional on the previous value.\n\nA better avenue would be to use a Metropolis random walk for $\\tau^{\\star}$, simulate $\\boldsymbol{\\beta} \\mid \\tau^{\\star}$ and propose the joint vector $(\\tau^{\\star}, \\boldsymbol{\\beta}^{\\star})$ simultaneously.\n\n## One step further\n\nWe could also remove the data augmentation step and propose from a Gaussian approximation of the log likelihood, using\na Taylor series expansion of the log likelihood about $\\boldsymbol{\\beta}_{t-1}$\n\\begin{align*}\n \\log p(\\boldsymbol{\\beta} \\mid \\boldsymbol{y}) \\stackrel{\\boldsymbol{\\beta}}{\\propto} - \\frac{\\tau}{2} \\boldsymbol{\\beta}^\\top \\mathbf{Q} \\boldsymbol{\\beta} + \\sum_{t=1}^T \\log f(y_t \\mid \\beta_t)\n\\end{align*}\nand the $y_t$ are conditionally independent in the likelihood. Refer to Section 4.4.1 of @Rue.Held:2005 for more details.\n\n## Technical aside: in sparsity we trust!\n\nIt is crucial to exploit the sparsity structure of $\\mathbf{Q}$ for efficient calculations of the likelihood\n\n- typically requires re-ordering elements to get a banded precision matrix\n- precompute the sparse Cholesky\n- compute inverse by solving systems of linear equations; there are dedicated algorithms\n\n\n## References\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}