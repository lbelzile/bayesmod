{
  "hash": "537229d60c2e2bbfe2b8b7428e6cee51",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Solution 6\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Exercise 6.1\n\nConsider the eight school data from Educational Testing Service (ETS), featured prominently in @Gelman:2013. The data shows results of randomized experiments in eight different schools to estimate the effect of coaching on SAT-V scores.\nThe data consist of estimated treatment mean difference and their standard errors. The data size are large, so the average treatment effect (ATE) can be considered Gaussian and the standard errors are treated as a known quantity.\n\n\n\n1. Derive the Gibbs sampler for the two models with improper priors. Note that, to sample jointly from $p(\\mu, \\boldsymbol{\\alpha} \\mid \\boldsymbol{y}, \\sigma^2_{\\alpha}, \\boldsymbol{\\sigma}^2_{\\boldsymbol{y}})$, you can draw from the marginal of $\\boldsymbol{\\alpha}$, then the conditional $\\mu \\mid \\boldsymbol{\\alpha}, \\cdots$.\n2. Fit the three algorithms described in @Gelman.vanDyk:2008 and compare their efficiency via effective sample size (ESS). In particular, draw traceplots and calculate effective sample sizes for \n    \n    - $\\mu$\n    - $\\alpha_1$, \n    - the sum $\\mu + \\alpha_1$.\n\nas well as pairs plot of $\\alpha_i, \\log \\sigma_{\\alpha}$. The latter should display a very strong funnel.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](06-solution_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n\nConsider a one-way ANOVA with a single observation per group, where for $i=1, \\ldots, n,$ we have\n\\begin{align*}\nY_{i} &\\sim \\mathsf{Gauss}(\\mu + \\alpha_i, \\sigma^2_i) \\\\\n\\alpha_i &\\sim \\mathsf{Gauss}(0, \\sigma^2_\\alpha)\n\\end{align*}\nand an improper prior for the mean $p(\\mu) \\propto 1.$\nIf there are $K$ groups, then the group-specific mean is $\\mu+\\alpha_k$, and there is a redundant parameter. In the Bayesian setting, the parameters are weakly identifiable because of the prior on $\\boldsymbol{\\alpha}$, but the geometry is such that $\\alpha_k \\to 0$ as $\\sigma^2_{\\alpha} \\to 0.$ See [Section 5.5](https://users.aalto.fi/~ave/BDA3.pdf) on p. 119 of @Gelman:2013 for more details.\n\nWe fit the model by adding redundant parameter to improve mixing [@Gelman.vanDyk:2008]\n\\begin{align*}\nY_{i} &\\sim \\mathsf{Gauss}(\\mu + \\alpha\\xi_i, \\sigma^2_i) \\\\\n\\xi_i &\\sim \\mathsf{Gauss}(0, \\sigma^2_\\xi)\n\\end{align*}\nso that $\\sigma_\\alpha = |\\alpha|\\sigma_\\xi.$\n\n\nSee this [post](https://xuwd11.github.io/am207/wiki/gelmanschools.html) for display of the pathological behaviour that can be captured by divergence in Hamiltonian Monte Carlo.\n\n\n:::{.solution}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Eight school data\nes <- data.frame(school = LETTERS[1:8], \n                 y = c(28, 8, -3, 7, -1, 1, 18, 12), \n                 se = c(15, 10, 16, 11, 9, 11, 10, 18))\nn <- nrow(es)\nB <- 1e3L\nset.seed(80601)\n# Starting values\nalpha <- rnorm(0, sd = 0.01)\nmu <- mean(es$y)\nsigma_al <- sqrt(var(es$y) - mean(es$se))\npars1 <- matrix(NA, nrow = B, ncol = n + 2)\nvar_mu <- 1/sum(1/es$se^2)\nfor(b in seq_len(B)){\n  var_al <- 1/(1/es$se^2 + 1/sigma_al^2)\n  pars1[b, 1:n] <- alpha <- rnorm(n = n, mean = var_al * (es$y - mu)/es$se^2, sd = sqrt(var_al))\n  pars1[b, n + 1] <- mu <- rnorm(n = 1, mean = var_mu * sum((es$y - alpha)/es$se^2), sd = sqrt(var_mu)) \n  pars1[b, n + 2] <- sigma_al <- sum(alpha^2) / rchisq(1, df = n - 1) \n}\n\n## Sampler 2\n# Same model, with joint updates\nset.seed(80601)\n# Starting values\nalpha <- rnorm(0, sd = 0.01)\nmu <- mean(es$y)\nsigma_al <- sqrt(var(es$y) - mean(es$se))\npars2 <- matrix(NA, nrow = B, ncol = n + 2)\nfor(b in seq_len(B)){\n  var_al <- 1/(1/es$se^2 + 1/sigma_al^2)\n  # Sample from joint of alpha, mu\n  # by taking p(alpha | sigma_al, y) * p(mu | alpha, sigma_al, y)\n  pars2[b, 1:n] <- alpha <- rnorm(n = n, mean = var_al * es$y/es$se^2, sd = sqrt(var_al))\n  pars2[b, n + 1] <- mu <- rnorm(n = 1, mean = var_mu * sum((es$y - alpha)/es$se^2), sd = sqrt(var_mu)) \n  pars2[b, n + 2] <- sigma_al <- sum(alpha^2) / rchisq(1, df = n - 1) \n}\n\n# Parameter expansion - V+PX sampler\na <- 1\npars3 <- matrix(NA, nrow = B, ncol = n + 3)\nfor(b in seq_len(B)){\n  var_al <- 1/(1/es$se^2 + 1/sigma_al^2)\n  # Sample from joint of alpha, mu\n  # by taking p(alpha | sigma_al, y) * p(mu | alpha, sigma_al, y)\n  alpha_st <- rnorm(n = n, mean = var_al * es$y/es$se^2, sd = sqrt(var_al))\n  pars3[b, n + 1] <- mu <- rnorm(n = 1, mean = var_mu * sum((es$y - alpha)/es$se^2), sd = sqrt(var_mu)) \n  pars3[b, n + 2] <- sigma_al_st <- sum(alpha_st^2) / rchisq(1, df = n - 1) \n  pars3[b, n + 3] <- a <- rnorm(n = 1, mean = sum(alpha_st*(es$y-mu)/es$se^2)/sum(alpha_st^2/es$se^2), \n                                sd = sqrt(sum(alpha_st^2/es$se^2)))\n  pars3[b, 1:n] <- alpha_st*a\n  pars3[b, n + 2] <- sigma_al <- abs(a)*sigma_al_st\n}\n```\n:::\n\n\n\n\nWe can write the joint density of $\\mu$ and $\\boldsymbol{\\alpha}$ and integrate out $\\mu$. The precision for $\\alpha_j$ is $Q_{\\alpha_j} = 1/\\sigma^2_j + 1/\\sigma_{\\alpha}^2$, and the unconditional mean of $p(\\alpha_j \\mid \\sigma_{\\alpha})$ is $Q^{-1}_{\\alpha_j}y_j/\\sigma^2_j$. The conditional distribution $p(\\mu, \\mid \\boldsymbol{\\alpha}, \\sigma_{\\alpha})$ is Gaussian with precision $Q_{\\mu} = \\sum_{j=1}^{8} \\sigma^{-2}_j$ and mean $Q_{\\mu}^{-1}\\sum_{j=1}^8 \\sigma^{-2}_j(y_j-\\alpha_j).$ The other steps are detailed in @Gelman.vanDyk:2008.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](06-solution_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](06-solution_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](06-solution_files/figure-html/unnamed-chunk-4-3.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n<!--\nRun four Markov chains to estimate the parameters with different starting values and store the posterior parameters. For each posterior draw, sample a corresponding data set from the posterior predictive with the same size as the original.\n\n1. Plot the chain including burn in and warmup period. How many iterations does it take for the chains to stabilize?\n2. Estimate the quartiles and report adjusted Monte Carlo standard errors based on the effective sample size.\n3. Calculate the $\\widehat{R}$ factor for each parameter.\n4. **Posterior predictive check**: for each simulated dataset from the posterior predictive,\n     a. plot their density and compare with that of the original data.\n     b. Compare the posterior std. deviation and the range.\n     c. Compute the leave-one-out cross validated probability integral transform\n5. Compute WAIC\n-->\n\n## Exercise 6.2\n\nLet $Y_{ij1}$ ($Y_{ij2}$) denote the score of the home (respectively visitor) team for a soccer match opposing teams $i$ and $j$. @Maher:1982 suggested modelling the scores as\n\\begin{align*}\nY_{ij1} \\mid \\delta, \\alpha_i, \\beta_j &\\sim \\mathsf{Poisson}\\{\\exp(\\delta + \\alpha_i +\\beta_j)\\},\n\\\\ Y_{ij2} \\mid \\delta, \\alpha_j, \\beta_i &\\sim \\mathsf{Poisson}\\{\\exp(\\alpha_j+\\beta_i)\\},\n\\end{align*}\nwhere \n\n- $\\alpha_i$ represent the offensive strength of the team, \n- $\\beta_j$ the defensive strength of team $j$ and \n- $\\delta$ is the common home advantage. \n\nThe scores in a match and between matches are assumed to be conditionally independent of one another given $\\boldsymbol{\\alpha}, \\boldsymbol{\\beta}, \\delta$. The data set [`efl`](/files/data/efl.csv) contains the results of football (soccer) matches for the 20232-2024 season of the English Football Ligue (EFL) and contains the following variables\n\n- `score`: number of goals of `team` during a match\n- `team`: categorical variable giving the name of the team which scored the goals\n- `opponent`: categorical variable giving the name of the adversary\n- `home`: binary variable, 1 if `team` is playing at home, 0 otherwise.\n\n\n1. Specify suitable priors for the regression parameters that shrink $\\alpha_i$ and $\\beta_j$ to zero.\n2. Fit the model: \n   - Using the posterior distribution, give the expected number of goals for a match between Manchester United (at home) against Liverpool.\n   - Report and interpret the estimated posterior mean home advantage $\\widehat{\\delta}$. \n   - Calculate the probability that the home advantage $\\delta$ is positive?\n3. Comment on the adequacy of the fit by using a suitable statistic for the model fit (e.g. the deviance statistic\n4. Maher also suggested more complex models, including one in which the offensive and defensive strength of each team changed depending on whether they were at home or visiting another team, i.e.\n\\begin{align}\nY_{ij1} \\sim \\mathsf{Poisson}\\{\\exp(\\alpha_i +\\beta_j + \\delta)\\}, \nY_{ij2} \\sim \\mathsf{Poisson}\\{\\exp(\\gamma_j+\\omega_i)\\},\n\\end{align}\nDoes the second model fit significantly better than  than the first? Compare the models using WAIC and Bayes factors.\n\n:::{.solution}\n\nWe use the `brms` package to generate Stan code following **R** syntax. Model 1 can be fit by adding random effects for `team` and `opponent`. These are assigned penalized complexity priors for the scale such that their 0.99 quantile is 1, giving $1-\\exp(-\\lambda_0) = 0.99$ and thus $\\lambda_0=-\\log (0.01).$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(brms)\ndata(efl, package = \"hecbayes\")\n# Model 1\nfit_brms1 <- brms::brm(formula = score ~ home + (1 | team) + (1 | opponent),\n                 data = efl, \n                 prior = c(\n                   set_prior(\"normal(0, 10)\", class = \"b\", coef = \"home\"),\n                   set_prior(\"exponential(4.605)\", class = \"sd\", group = \"team\"),\n                   set_prior(\"exponential(4.605)\", class = \"sd\", group = \"opponent\")\n                 ),\n                 family = poisson, \n                 silent = 2, \n                 open_progress = FALSE,\n                 refresh = 0,\n                 save_model = \"Maher1.stan\", \n                 seed = 1)\nsummary(fit_brms1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: poisson \n  Links: mu = log \nFormula: score ~ home + (1 | team) + (1 | opponent) \n   Data: efl (Number of observations: 760) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nMultilevel Hyperparameters:\n~opponent (Number of levels: 20) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.24      0.05     0.15     0.36 1.00     1581     2354\n\n~team (Number of levels: 20) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.25      0.05     0.16     0.38 1.00     1280     2344\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept     0.34      0.09     0.15     0.51 1.00     1624     2430\nhome          0.20      0.06     0.09     0.31 1.00     7522     2961\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n\n```{.r .cell-code}\n# Use S3 generic for prediction, with new data frame\npredict(fit_brms1, newdata = data.frame(home = 1, team = \"Man Utd\", opponent = \"Liverpool\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Estimate Est.Error Q2.5 Q97.5\n[1,]  1.25875  1.139352    0     4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Manual prediction from posterior predictive\n# 1) extract simulations\nsims <- fit_brms1$fit@sim$samples[[1]]\nnsim <- length(sims[[1]])\n# 2) calculate the posterior mean for the match for each team (Poisson with log link)\npost_mean1 <- exp(sims$b_Intercept + sims$b_home + sims$`r_opponent[Liverpool,Intercept]` + sims$`r_team[Man.Utd,Intercept]`)\npost_mean2 <- exp(sims$b_Intercept + sims$`r_team[Liverpool,Intercept]` + sims$`r_opponent[Man.Utd,Intercept]`)\n# 3) generate the number of goals from the posterior predictive\npost_pred1 <- rpois(n = nsim, lambda = post_mean1)\npost_pred2 <- rpois(n = nsim, lambda = post_mean2)\n# Plot the posterior predictive (bar plot)\ng1 <- ggplot(data = data.frame(x = c(post_pred1, post_pred2),\n                         team = rep(c(\"Manchester United\", \"Liverpool\"), each = nsim)),\n       aes(x = x, fill = team)) + \n  geom_bar(position = position_dodge()) + \n  labs(x = \"number of goals\") \ng2 <- ggplot(data = data.frame(delta = exp(sims$b_home)),\n             mapping = aes(x = delta)) +\n  geom_density() + \n  labs(x = expression(\"home advantage\"~exp(delta))) \ng1 + g2\n```\n\n::: {.cell-output-display}\n![](06-solution_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Model 2\nfit_brms2 <- brms::brm(formula = score ~ home + (1 | team) + (1 | opponent),\n                 data = efl, \n                 prior = c(\n                   set_prior(\"normal(0, 10)\", class = \"b\", coef = \"home\"),\n                   set_prior(\"exponential(4.605)\", class = \"sd\", group = \"team\"),\n                   set_prior(\"exponential(4.605)\", class = \"sd\", group = \"opponent\")\n                 ),\n                 family = poisson, \n                 save_model = \"Maher2.stan\",\n                 silent = 2, \n                 open_progress = FALSE,\n                 refresh = 0)\nsummary(fit_brms2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: poisson \n  Links: mu = log \nFormula: score ~ home + (1 | team) + (1 | opponent) \n   Data: efl (Number of observations: 760) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nMultilevel Hyperparameters:\n~opponent (Number of levels: 20) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.24      0.05     0.15     0.36 1.00     1494     2626\n\n~team (Number of levels: 20) \n              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(Intercept)     0.25      0.05     0.16     0.37 1.00     1731     2403\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept     0.34      0.09     0.16     0.52 1.00     1672     2242\nhome          0.20      0.06     0.09     0.31 1.00     9488     2716\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n\n```{.r .cell-code}\nwaic(fit_brms1); waic(fit_brms2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nComputed from 4000 by 760 log-likelihood matrix.\n\n          Estimate   SE\nelpd_waic  -1170.7 16.4\np_waic        27.8  1.5\nwaic        2341.5 32.9\n\n2 (0.3%) p_waic estimates greater than 0.4. We recommend trying loo instead. \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nComputed from 4000 by 760 log-likelihood matrix.\n\n          Estimate   SE\nelpd_waic  -1170.7 16.4\np_waic        27.7  1.5\nwaic        2341.4 32.9\n\n2 (0.3%) p_waic estimates greater than 0.4. We recommend trying loo instead. \n```\n\n\n:::\n:::\n\n\n\n\n\nWe can also fit the model using integrated nested Laplace approximations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(INLA)\n# Default prior for random effects\n# inla.models()$latent$iid$hyper$theta\nprec_prior <- list(theta = list(prior = \"pc.prec\", param = c(1, 0.01)))\nfit_inla <- INLA::inla(\n  score ~ home + f(team, model = \"iid\", hyper = prec_prior) +\n    f(opponent, model = \"iid\", hyper = prec_prior),\n  family = \"poisson\",\n  data = efl)\nmarg_delta <- fit_inla$marginals.fixed[[2]]\ninla.pmarginal(q = 0, marginal = inla.smarginal(marg_delta))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0002693049\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = data.frame(inla.smarginal(marg_delta)), mapping = aes(x = x, y = y)) + \n  geom_line() + \n  labs(x = expression(delta), y  = \"\", subtitle = \"Marginal density of home advantage\") + \n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](06-solution_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n",
    "supporting": [
      "06-solution_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}