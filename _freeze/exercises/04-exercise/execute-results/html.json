{
  "hash": "77280bc069bbff0870b388427055646d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exercises 4\"\n---\n\n\n\n\n\n## Exercise 4.1\n\nConsider the Laplace family of distribution, $\\mathsf{Laplace}(\\nu, \\tau)$, with density\n\\begin{align*}\ng(x; \\nu, \\tau) = \\frac{1}{2\\tau} \\exp\\left(- \\frac{|x-\\nu|}{\\tau}\\right), \\qquad \\nu \\in \\mathbb{R}, \\tau > 0\n\\end{align*}\nas a candidate distribution for rejection sampling from $\\mathsf{Gauss}(0,1).$\n\n1. Provide an inversion sampling algorithm to generate from $\\mathsf{Laplace}(\\nu, \\tau).$\n2. Can you use the proposal to generate from a standard Gaussian? for Student-$t$ with 1 degree of freedom? Justify your answer.\n3. Consider as proposal a location-scale version of the Student-t with $\\nu=3$\n degrees of freedom. Find the optimal location and scale parameters and the upper bound $C$ for your choice.\n4. Use the accept-reject to simulate 1000 independent observations and compute the empirical acceptance rate.\n\n## Exercise 4.2\n\n\nWe revisit [Exercise 2.3](/exercises/02-exercise.html#exercice-2.3), which used a half-Cauchy prior for the exponential waiting time of buses.\n\nThe ratio-of-uniform method, implemented in the [`rust` **R** package](https://paulnorthrop.github.io/rust/index.html), can be used to simulate independent draws from the posterior of the rate $\\lambda$.\nThe following code produces \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnobs <- 10L # number of observations\nybar <- 8   # average waiting time\nB <- 1000L  # number of draws\n# Un-normalized log posterior: scaled log likelihood + log prior\nlog_post <- function(x){ \n  dgamma(x = x, shape = nobs + 1L, rate = nobs*ybar, log = TRUE) +\n    log(2) + dt(x = x, df = 1, log = TRUE)}\npost_samp <- rust::ru(logf = log_post, \n                      n = B, \n                      d = 1,  # dimension of parameter (scalar)\n                      init = nobs/ybar)$sim_vals # initial value of mode\n```\n:::\n\n\n\nEstimate using the independent Monte Carlo samples:\n\n1. the probability that the waiting time is between 3 and 15 minutes\n2. the average waiting time\n3. the standard deviation of the waiting time.\n\n\nNext, implement a random walk Metropolis--Hastings algorithm to sample draws from the posterior and re-estimate the quantities. Compare the values and the standard errors of the posterior mean for $\\lambda.$\n\n<!--\n\nRepeat the simulations in Example 3.6, this time with a parametrization in terms of log rates $\\lambda_i$ $(i=1,2)$, with the same priors. Use a Metropolis--Hastings algorithm with a Gaussian random walk proposal, updating parameters one at a time. Run four chains in parallel.\n\n\n1. Tune the variance to reach an approximate acceptance rate of 0.44.\n2. Produce diagnostic plots (scatterplots of observations, marginal density plots, trace plots and correlograms). See [`bayesplot`](http://mc-stan.org/bayesplot/articles/plotting-mcmc-draws.html) or `coda`. Comment on  the convergence and mixing of your Markov chain Monte Carlo.\n3. Report summary statistics of the chains.\n\n-->\n\n## Exercise 4.3\n\nConsider the following code which implements a Metropolis--Hastings algorithm to simulate observations from a $\\mathsf{beta}(0.5, 0.5)$ density.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_f <- function(par){\n  dbeta(x = par, shape1 = 0.5, shape2 = 0.5, log = TRUE)\n}\nmetropo <- function(B, sd_prop = 0.2){\n  chain <- rep(0, B)\n  # Draw initial value\n  cur <- runif(1)\n  for(b in seq_len(B)){\n    repeat {\n        # Simulate proposal from Gaussian random walk proposal\n        prop <- cur + rnorm(1, sd = sd_prop)\n        # check admissibility for probability of success\n        if (prop >= 0 & prop <= 1)\n          break\n    }\n    # Compute (log) acceptance ratio\n    logR <- log_f(prop) - log_f(cur) \n    # Accept the move if R > u\n    if(isTRUE(logR > log(runif(1)))){\n     cur <- prop \n    }\n    chain[b] <- cur\n  }\n  return(chain)\n}\n# Run MCMC for 10K iterations\nmc <- metropo(1e4L)\n```\n:::\n\n\n\nTo see if the algorithm works:\n\na. Plot the density of the Markov chain draws along with the beta density curve. \nb. Check that empirical moments match the theoretical ones\n\nIf the algorithm is incorrect, provide a fix and explain the reason for the problem.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}